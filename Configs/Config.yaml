# reference guided assembly 管道参数配置文件
## Test on chm13 hifi
# ctg_ls: [chr1,chr2,chr3]  # 需要分析的contig列表
# minimap2默认：-k 15, -f 0.0002, -w 10(INT Minimizer window size [2/3 of k-mer length]),
# map-ont：为默认参数
# map-hifi (-k19 -w19 -U50,500 -g10k -A1 -B4 -O6,26 -E2,1 -s200).
# 可调整：-w30 -k19 -I 50g -K 50G
# -I 50g -K 50G为有效参数 -I, 80g, -K, 80G
# -k <= 28
# cpu:192GB、fat:1.5TB 
# -k -w可以牺牲精度增加速 ont: -w16, -k24; hifi: -w21, -k27
# 对于小基因组,有时候不需要加-K50G -I50G
# ont:开-K -I有效；hifi:开-K -I会降低速度
# --secondary=no对大型基因组能有效降低时间
# -w16, -k24 | -w21, -k27 | -w27, -k27
# 小数据: 只调-k -w, --secondary=no没有效果
# 调-w -k后不需要调-I -K
# 待办：引入min_MQ到候选区域检测中，设定min_MQ
### step1
step1:
  # minimap2_params_ls: [-I, 50g, -K, 50G]    # 
  # minimap2_params_ls: [--secondary=no, -w16, -k24]  # ont
  minimap2_params_ls: [--secondary=no, -w27, -k27]  # hifi

### step2
step2:
  dp_params:
    dp_upper_bound: 1.45   # 30 -> 48, dp * upper_bpund -> upper_dp   1.45
    dp_lower_bound: 0.35    # 30-> 9, dp * lower_bpund -> lower_dp    0.35
    dp_win_size: 100  # win_size of tool(mosdepth) to calculate depth
    block_size: 10000000   # 计算每个block的标准depth值
    cluster_dis: 1000   # 对找到的区间进行一轮聚类
    min_MQ: 20  # 
  clip_params:
    min_clip_len: 500 # 超过这个长度的认为是异常clip。abnormal clip。需要对hifi数据和ont数据的clip进行一定的统计
    min_clip_portion: 0.25  # 0.15
    min_clip_num: 5   # 超过这个数目，认为是异常区域。与覆盖度有关，需要对覆盖度进行一定的分析
    clip_win_size: 1000 #
    min_MQ: 0  # 
  apply_pileup: true
  pileup_params:
    reg_size: 2000000
    win_size: 400   # 1000
    step_size: 200  # 500
    cluster_dis: 1000
    min_MQ: 0  # 
    ont:
      min_correct_portion: 0.9    # hifi:0.95   一致性比例（类似identity）
      max_differ_portion: 0.15     # hifi:0.1    插入删除的不一致比例  
      max_disagree_portion: 0.02  # hifi: 0.015    单碱基不一致比例，用来暗示一些隐含的比对错误区域。但是对某些生物，基因组可能存在大量的snp，就需要把值开大点
    hifi:
      min_correct_portion: 0.95    # hifi:0.95   一致性比例（类似identity）
      max_differ_portion: 0.1     # hifi:0.1    插入删除的不一致比例  
      max_disagree_portion: 0.015  # hifi: 0.015    单碱基不一致比例，用来暗示一些隐含的比对错误区域。但是对某些生物，基因组可能存在大量的snp，就需要把值开大点

### step3
step3:
  apply_scaffod: true   # 执行桥接算法
  apply_read_patch_first: true
  high_clip:
    apply_on_high_clip: true
    min_high_clip_num: 6
    min_portion: 0.2  # clip_num / depth, 数目占深度比例
    min_clip_len_portion: 0.1 # clip_len/read_len, 0.2
  min_denovo_to_keep: 10000 # 集成到过滤器里面去
  remove_secondary: true
  reg_expand_dis: 500   # 对第二步的候选区间进行扩充
  depths: 
    win_size: 100 # 
    block_size: 5000  # 用于求block dp的
  ## 
  solve_by_read: 
    # dp_upper_bound: 3   # 用读数能解决的上限，对读数解决区域的dp进行限制
    block_high_dp_bound: 2.5  # 
  solve_by_denovo:
    min_align_length: 10000
    min_dis: 1000
  denovo_asm:
    hifi: hifiasm # 
    ont: shasta   # flye、wtdbg2、shasta  shasta用于人类纳米孔数据组装效果比较好
    shasta_option_ls: [--config, Nanopore-May2022]  # other_ont
    # shasta_option_ls: [--config, Nanopore-Human-SingleFlowcell-May2022] # human
    hifiasm_option_ls: [-l0]
    wtdbg2_option_ls: []
    flye_option_ls: []  # choose (--meta metagenome / uneven coverage mode)
    miniasm_option_ls: []
  ## 聚类参数
  get_candidate_op:
    clip_merge_dis: 1000  # 1000
    merge_by_clip_dp: false   # 效果不太行，且十分费时，false
    asm_candidate_cluster_dis: 20000  # 初始一轮聚类  20000
  cluster_by_asm_candidate:   # 根据asm区域进行聚类
    radius_1: 10000   # 第一轮简单聚类，合并asm region周边的reads区域
    radius_2: 40000  # 最后一轮Merge local asm region and expand region
    radius_3: 1000000 # 暂未使用的参数
    # 区间扩充的参数
    reg_len_2: 60000    # 20000/50000
    reg_len_3: 1000000  # 1000000
    reg_expand_1: 15000   # 对所有候选区域进行的扩充          10000/20000
    reg_expand_2: 30000   # >reg_len_2，大型基因组可以开大点  20000/30000
    reg_expand_3: 50000   # >reg_len_3                      80000
    # 两轮聚类: 大的聚类，用于人类基因组
    big_cluster:
      apply_big_cluster: false   # true/false 主要用于人类基因组中心粒区域和一些大的区域的合并
      ## 按照区间大小和距离进行聚类
      reg_size: 100       # 聚类的区间大小
      cluster_dis: 200000 # 按这个尺度来聚类
      ## 按照密度进行聚类
      radius: 2000000   # 计算密度的尺度
      clu1: 1000000     # 一级聚类
      clu2: 500000      # 
      t1: 100000        # 区间大小定义：t1表示超大区间，t2表示中等区间
      t2: 10000         # 
  ## Deprecated
  apply_denovo_by_reg: false   # false 按区域可能失败
  denovo_by_reg: 
    max_reg_len: 1000000
    apply_bound: true  # 边界是否也算在里面
    keep_frage: false   # 最好不要收集, 有过多的重复组装碎片
    dp_upper_bound: 2.5   # dp max than this will
    block_high_dp_bound: 5
    parallel: true
  ## 
  apply_ctg_denovo: false   # 作为备选用于覆盖度的极不均匀contig
  denovo_by_ctg:
    apply_all: false     # true不管是否正常contig(也就是忽略下面的参数判断了)，全部apply_ctg_denovo。但是或许会引入太多的碎片不好处理，因此还是直接合并交给第三组。
    min_cov_ratio: 0.5  # abnormal contig
    dp_upper_bound: 2.5   # avg_ctg_dp / whole_dp
    dp_lower_bound: 0.1
  ##
  apply_contig_filter: true  # 对于局部ctg_asm，和最后的fragements这类数据，进行purgedups的过滤，否则可能引入过多的重复和垃圾碎片
  contig_filter: 
    min_len: 10000    # 保留contig长度
    purgedups: true   # 对一些重复的进行清除，根据比对的位置
    

### step4 polish
step4:
  # minimap2_params_ls: [--secondary=no]
  # minimap2_params_ls: [--secondary=no, -w16, -k24]  # ont
  minimap2_params_ls: [--secondary=no, -w27, -k27]  # hifi
  racon_params_ls: []

### step5 scaffolding 可能会有少量misassembly的增加
step5:
  Scaffold_Params:
    ## 50000、500000
    MAX_GAP: 500000  # gap 小于这个长度用于scaffolding。500000
    MIN_CONNECT_SEQ: 2000000 # 大于这个长度的序列用于scaffolding。1000000
    # MAX_GAP: 50000
    # MIN_CONNECT_SEQ: 200000
    N_fill_size: 20

